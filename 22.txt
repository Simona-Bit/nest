// 对 array 的 [low, high] 区间，做快速排序
void qSort(int[] array, int low, int high) {
??if (low == high) {
????// [low, high] 区间内只有一个数了，一定是有序的，不需要进行排序
????return;
?}
?
??if (low > high) {
????// [low, high] 区间内没有数了，不需要进行排序
????return;
?}
?
??int pivot_index; // 经过 partition 后，基准值所在下标
??pivot_index = partition(array, low, high);
?// [low, pivot_index - 1] 都是 小于 pivot 的数
??// [pivot_index + 1, high] 都是 大于等于 pivot 的数
??qSort(array, low, pivot_index - 1);
??qSort(array, low, pivot_index + 1);
}



//快速排序非递归
void quickSortNonRecursion(int[] array) {
??// 最差情况下也就是这个了，一般用不了这么多，空间复杂度是 O(log(n)) ~ O(n)
??int[] stack = new int[array.length * 2];
??int top = 0;
??stack[top++] = array.length - 1; ??// high
??stack[top++] = 0; ?????????// low
??while (top > 0) {
????int low = stack[--top];
????int high = stack[--top];
????if (low >= high) {
??????continue;
???}
????int d = partition(array, low, high);
????// [d + 1, high]
????stack[top++] = high;
????stack[top++] = d + 1;
// [low, d - 1]
????stack[top++] = d - 1;
????stack[top++] = low;
?}
}